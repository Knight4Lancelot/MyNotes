**创建型模式 - 简单工厂模式**

# 1、主要组成部分

**工厂类：** 负责创建对象的类。包含一个创建的方法，根据传入的参数决定具体创建哪种具体的产品。

**产品接口：** 定义了产品的基本行为和属性，所有具体产品类都需要实现这个接口。

**具体产品类：** 实现了产品接口的具体类，表示工厂可以创建的具体对象。

# 2、举例说明

```C++
// 产品接口：People类
class People {
public:
    People(std::string name, int age, std::string gender): _name(name), _age(age), _gender(gender) {}
    virtual ~People() {}
protect:
    std::string _name;
    int _age;
    std::string _gender;
};

// 具体产品类：Teacher类
class Teacher: public People {
public:
    Teacher(std::string name, int age, std::string gender, int tId): People(name, age, gender), _tId(tId) {}
private:
    int _tId;
};

// 具体产品类：Student类
class Student {
public:
    Student(std::string name, int age, std::string gender, int sId): People(name, age, gender), _sId(sId) {}
private:
    int _sId;
};

// 工厂类：PeopleFactory类
class PeopleFactory {
public:
    People* createPeople(string type)
    {
        People* peoplePtr = nullptr;
        if (type == "student") {
            peoplePtr = new Student("defaultName", 20, "男", 1001);
        } else if (type == "teacher") {
            peoplePtr = new Teacher("defaultName", 30, "男", 2001);
        }
        return peoplePtr;
    }
};
```

利用上面的类的定义，可以通过`PeopleFactory`类创建具体的`People`对象。

```C++
int main()
{
    PeopleFactory factory;
    People* stu1 = factory.createPeople("student");
    People* stu2 = factory.createPeople("student");
    People* tea1 = factory.createPeople("teacher");
    // 进行一些操作
    delete stu1;
    delete stu2;
    delete tea1;
}
```

# 3、优缺点分析

**优点：**

（1）简化客户端代码：客户端只需通过工厂类获取对象，而无需了解对象的具体创建过程。

（2）集中管理对象创建：所有对象的创建逻辑集中在工厂类中，便于维护和管理。

（3）易于扩展：新增产品时，只需在工厂类中添加相应的创建逻辑，客户端代码无需修改。

**缺点：**

（1）违反开闭原则：增加新产品需要修改工厂类的代码，导致工厂类可能变得臃肿。

（2）赖于字符串参数：客户端需要了解产品类型的字符串标识，可能导致错误和不易维护。

（3）不适合产品种类过多的情况：如果产品种类增多，工厂类会变得复杂且难以管理。

**适用场景：**

（1）产品具有相似结构：当需要创建的对象具有相似的结构或特性，且种类较少时。

（2）客户端不关心创建过程：客户端希望通过简单的接口获取对象实例，而不关心其创建细节。

（3）快速原型开发：在项目初期，快速实现功能时，可以使用简单工厂模式减少复杂性。

（4）动态创建对象：需要根据不同条件动态创建对象的情况，适合使用简单工厂模式。